<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cattail Treatments - Technical Notes</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 8px;
        }
        h3 {
            color: #7f8c8d;
            margin-top: 20px;
        }
        h4 {
            color: #95a5a6;
            margin-top: 15px;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #e74c3c;
        }
        pre {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            border: 1px solid #34495e;
        }
        pre code {
            background-color: transparent;
            color: #ecf0f1;
            padding: 0;
            border-radius: 0;
            font-size: 0.85em;
        }
        ul, ol {
            margin: 10px 0;
            padding-left: 30px;
        }
        li {
            margin: 5px 0;
        }
        blockquote {
            border-left: 4px solid #3498db;
            background-color: #f8f9fa;
            padding: 10px 20px;
            margin: 20px 0;
            font-style: italic;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f5f5f5;
            font-weight: bold;
        }
        hr {
            border: none;
            height: 2px;
            background-color: #ecf0f1;
            margin: 20px 0;
        }
        p {
            margin: 10px 0;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
<h1>Cattail Treatments - Technical Notes</h1>

<h2>Overview</h2>
<p>This Shiny app tracks cattail treatment progress at mosquito breeding sites across three perspectives:</p>
<ol>
<li><strong>Progress Overview</strong> - Sites with inspection status and treatment progress, aggregated by facility, FOS, or section</li>
<li><strong>Historical Analysis</strong> - Multi-year trends in cattail inspections and treatments </li>
<li><strong>Future Tabs</strong> - Treatment planning and management (to be developed)</li>
</ul>

<h2>Data Sources</h2>

<h3>Core Database Tables and Columns</h3>

<h4>Primary Inspection Tables</h4>
<ul>
<li><strong><code>public.dblarv<em>insptrt</em>current</code></strong> - Active larval inspection records</li>
<ul>
<li><strong>Key Columns</strong>: <code>sitecode</code>, <code>inspdate</code>, <code>action</code>, <code>numdip</code>, <code>matcode</code>, <code>mattype</code>, <code>amts</code>, <code>acres</code></li>
<li><strong>Cattail Filter</strong>: <code>action = '9'</code> (inspection) with <code>numdip</code> determining treatment need</li>
<li><strong>Missing Columns</strong>: Does NOT contain <code>zone</code>, <code>enddate</code>, <code>facility</code> - must join for these</li>
<li><strong>Data Quality</strong>: Contains ongoing inspection records with cattail dip counts</li>
</ul>
</ul>

<ul>
<li><strong><code>public.dblarv<em>insptrt</em>archive</code></strong> - Historical larval inspection/treatment records  </li>
<ul>
<li><strong>Key Columns</strong>: <code>sitecode</code>, <code>inspdate</code>, <code>action</code>, <code>numdip</code>, <code>matcode</code>, <code>mattype</code>, <code>amts</code>, <code>acres</code></li>
<li><strong>Cattail Filter</strong>: <code>action = '9'</code> (inspection) OR <code>action IN ('3', 'A')</code> (treatments)</li>
<li><strong>Missing Columns</strong>: Does NOT contain <code>zone</code>, <code>enddate</code>, <code>facility</code> - must join for these</li>
<li><strong>Data Quality</strong>: Historical closed inspection/treatment records, generally more reliable</li>
</ul>
</ul>

<h4>Primary Treatment Tables  </h4>
<ul>
<li><strong><code>public.dblarv<em>insptrt</em>current</code></strong> - Active larval treatment records</li>
<ul>
<li><strong>Key Columns</strong>: <code>sitecode</code>, <code>inspdate</code>, <code>action</code>, <code>matcode</code>, <code>mattype</code>, <code>amts</code>, <code>acres</code></li>
<li><strong>Treatment Filter</strong>: <code>action IN ('3', 'A')</code> with cattail material codes</li>
<li><strong>Treatment Actions</strong>: </li>
<ul>
<li><code>action = '3'</code> - Standard treatment application</li>
<li><code>action = 'A'</code> - Alternative treatment application</li>
</ul>
<li><strong>Data Quality</strong>: Contains ongoing treatments, some may be planned vs executed</li>
</ul>
</ul>

<ul>
<li><strong><code>public.dblarv<em>insptrt</em>archive</code></strong> - Historical larval treatment records  </li>
<ul>
<li><strong>Same structure as current table</strong></li>
<li><strong>Data Quality</strong>: Historical closed treatments, generally more reliable than current</li>
</ul>
</ul>

<h4>Essential Supporting Tables</h4>
<ul>
<li><strong><code>public.loc<em>breeding</em>sites</code></strong> - Site master data</li>
<ul>
<li><strong>Key Columns</strong>: </li>
<ul>
<li><code>sitecode</code> (unique site identifier)</li>
<li><code>acres</code> (site capacity, not treated acres)</li>
<li><code>enddate</code> (<strong>CRITICAL</strong>: NULL = active site, NOT NULL = closed site)</li>
<li><code>air_gnd</code> (treatment method designation) </li>
<li><code>drone</code> (values: 'Y', 'M', 'C' for drone-capable sites)</li>
<li><code>geom</code> (PostGIS geometry data for mapping, UTM projection)</li>
</ul>
<li><strong>Critical Join Logic</strong>: <strong>MUST filter <code>enddate IS NULL</code></strong> or risk including closed sites</li>
<li><strong>Data Quality</strong>: Single row per sitecode for active sites</li>
<li><strong>Usage</strong>: Source of truth for site characteristics and active status</li>
</ul>
</ul>

<ul>
<li><strong><code>public.gis_sectcode</code></strong> - Geographic section mapping and zone assignments</li>
<ul>
<li><strong>Key Columns</strong>:</li>
<ul>
<li><code>sectcode</code> (7-character section identifier, e.g. '191031N')</li>
<li><code>facility</code> (facility short code)</li>
<li><code>zone</code> (values: '1' = Zone 1, '2' = Zone 2)</li>
<li><code>fosarea</code> (FOS employee number assignment)</li>
</ul>
<li><strong>Join Pattern</strong>: <code>LEFT JOIN public.gis_sectcode sc ON LEFT(sitecode,7) = sc.sectcode</code></li>
<li><strong>Sitecode Formats Handled</strong>:</li>
<ul>
<li>Standard: <code>190208-003</code> → sectcode <code>1902080</code></li>
<li>Directional: <code>191102W010</code> → sectcode <code>1911020</code> </li>
</ul>
<li><strong>Data Quality</strong>: Authoritative source for facility, zone and FOS assignments</li>
</ul>
</ul>

<ul>
<li><strong><code>public.mattype<em>list</em>targetdose</code></strong> - Material codes and target programs</li>
<ul>
<li><strong>Key Columns</strong>:</li>
<ul>
<li><code>matcode</code> (material identifier, joins to inspection/treatment tables)</li>
<li><code>prgassign_default</code> (target program assignment)</li>
<li><strong>Cattail Filter</strong>: <code>prgassign_default = 'Cat'</code> identifies cattail materials</li>
</ul>
<li><strong>Usage</strong>: Validates that treatments use cattail-appropriate materials</li>
<li><strong>Treatment Logic</strong>: Used to identify valid cattail treatment materials</li>
</ul>
</ul>

<h3>Data Collection Strategy</h3>

<h4>Key Join Patterns Used Throughout Application</h4>

<p><strong>Standard Inspection-to-Site Join Pattern:</strong></p>
<pre><code class="sql">
-- Connect inspection records with site information
FROM public.dblarv_insptrt_current i
LEFT JOIN public.loc_breeding_sites b ON i.sitecode = b.sitecode
LEFT JOIN public.gis_sectcode sc ON LEFT(i.sitecode,7) = sc.sectcode
WHERE i.action = '9'  -- Action 9 = inspected
  AND (b.enddate IS NULL OR b.enddate &gt; CURRENT_DATE)  -- Active sites only
</code></pre>

<p><strong>Standard Treatment-to-Site Join Pattern:</strong></p>
<pre><code class="sql">
-- Connect treatment records with cattail material validation
FROM public.dblarv_insptrt_current t
LEFT JOIN public.gis_sectcode sc ON LEFT(t.sitecode,7) = sc.sectcode
WHERE t.action IN ('3', 'A')  -- Actions 3/A = treatments
  AND t.matcode IN (
    SELECT matcode 
    FROM public.mattype_list_targetdose
    WHERE prgassign_default = 'Cat'
  )
</code></pre>

<p><strong>Note</strong>: See "SQL Queries Reference" section below for complete, up-to-date query implementations.</p>

<h4>Critical Data Integration Notes</h4>

<p><strong>Sitecode Format Handling:</strong></p>
<ul>
<li><strong>Standard Format</strong>: <code>190208-003</code> (7-digit section + dash + site num)</li>
<li><strong>Directional Format</strong>: <code>191102W010</code> (6-digit + direction + site num)</li>
<li><strong>Join Logic</strong>: <code>LEFT(sitecode,7)</code> extracts section code for both formats</li>
<li><strong>Example</strong>: Both <code>190208-003</code> and <code>191102W010</code> → sectcodes <code>1902080</code> and <code>1911020</code></li>
</ul>

<p><strong>Inspection vs Treatment Acres:</strong></p>
<ul>
<li><strong>Site Acres</strong>: <code>loc<em>breeding</em>sites.acres</code> = site capacity/potential treatment area</li>
<li><strong>Treated Acres</strong>: <code>dblarv<em>insptrt</em>*.acres</code> = actual area treated in specific application</li>
<li><strong>Usage</strong>: Site acres for capacity analysis, treated acres for actual treatment metrics</li>
</ul>

<p><strong>Cattail Treatment Determination:</strong></p>
<ul>
<li><strong>Inspection Logic</strong>: <code>numdip &gt; 0</code> indicates site needs cattail treatment</li>
<li><strong>3-State System</strong>: </li>
<ul>
<li><code>under_threshold</code> (grey): <code>numdip = 0</code> - no treatment needed</li>
<li><code>need_treatment</code> (red): <code>numdip &gt; 0</code> - treatment required</li>
<li><code>treated</code> (green): site had treatment applied after inspection showing need</li>
</ul>
</ul>

<p><strong>Treatment Timing Logic:</strong></p>
<ul>
<li><strong>Inspection Season</strong>: Typically fall season of year N</li>
<li><strong>Treatment Season</strong>: Fall/winter of year N OR spring/summer of year N+1</li>
<li><strong>Treatment Windows</strong>:</li>
<ul>
<li>Fall/Winter: September-December of inspection year</li>
<li>Spring/Summer: May-July of year after inspection</li>
</ul>
<li><strong>Year Mapping</strong>: Spring/Summer treatments in year N+1 apply to year N inspections</li>
</ul>

<p><strong>Zone Assignment:</strong></p>
<ul>
<li><strong>Zone 1</strong>: <code>gis_sectcode.zone = '1'</code> </li>
<li><strong>Zone 2</strong>: <code>gis_sectcode.zone = '2'</code></li>
<li><strong>Missing Zones</strong>: Some sites may not have zone assignments in gis_sectcode</li>
</ul>

<p><strong>Material Code Validation:</strong></p>
<ul>
<li><strong>Cattail Materials</strong>: JOIN with <code>mattype<em>list</em>targetdose WHERE prgassign_default = 'Cat'</code></li>
<li><strong>Treatment Validation</strong>: Only treatments using cattail materials are counted</li>
<li><strong>Action Types</strong>: Both action '3' and action 'A' represent valid treatments</li>
</ul>

<h2>Tab 1: Progress Overview</h2>

<h3>Purpose</h3>
<p>Display current status of cattail sites with 3-state progress tracking (under threshold, need treatment, treated).</p>

<h3>Key Features</h3>
<ul>
<li><strong>Value boxes</strong> showing summary statistics (total sites inspected, sites needing treatment, sites treated, treatment completion percentage)</li>
<li><strong>Stacked progress chart</strong> showing 3-state breakdown by facility</li>
<li><strong>Zone filters</strong> - Zone 1, Zone 2, or both zones</li>
<li><strong>Facility filters</strong> - Individual facilities or all facilities combined</li>
<li><strong>Date range controls</strong> - Analysis date and year selection</li>
<li><strong>Refresh button</strong> - Manual data loading (no auto-refresh)</li>
</ul>

<h3>Data Flow</h3>
<ol>
<li>Query cattail inspection sites via <code>load<em>cattail</em>data()</code>:</li>
<ul>
<li>Filter for sites with cattail inspections (<code>action = '9'</code>)</li>
<li>Join with site characteristics and zone assignments</li>
<li>Get most recent inspection per site (DISTINCT ON sitecode)</li>
<li>Calculate treatment need based on <code>numdip &gt; 0</code></li>
</ul>
</ul>

<ol>
<li>Query cattail treatments via <code>load<em>cattail</em>treatments()</code>:</li>
<ul>
<li>Get treatments using cattail materials (<code>prgassign_default = 'Cat'</code>)</li>
<li>Include both action types ('3' and 'A') for treatments</li>
<li>Cover both treatment seasons (fall same year + spring next year)</li>
<li>Map treatments to inspection year using season logic</li>
</ul>
</ul>

<ol>
<li>Aggregate via <code>aggregate<em>cattail</em>data()</code>:</li>
<ul>
<li>Match treatments to sites that need treatment</li>
<li>Calculate 3-state metrics:</li>
<ul>
<li><code>under<em>threshold</em>sites</code>: Sites with <code>numdip = 0</code></li>
<li><code>need<em>treatment</em>sites</code>: Sites with <code>numdip &gt; 0</code> and no treatment</li>
<li><code>treated_sites</code>: Sites with <code>numdip &gt; 0</code> and treatment applied</li>
</ul>
<li>Calculate completion percentage</li>
</ul>
</ul>

<h3>Visualization</h3>
<ul>
<li><strong>3-state value boxes</strong>:</li>
<ul>
<li>Grey box: Sites under threshold (no treatment needed)</li>
<li>Red box: Sites needing treatment </li>
<li>Green box: Sites treated</li>
<li>Blue box: Treatment completion percentage</li>
</ul>
<li><strong>Stacked progress chart</strong>:</li>
<ul>
<li>Grey bars: Total sites under threshold</li>
<li>Red bars: Sites needing treatment (remaining)</li>
<li>Green bars: Sites treated</li>
<li>Colors consistent with 3-state system</li>
</ul>
</ul>

<h3>3-State Logic Implementation</h3>
<pre><code class="r">
# Sites categorized into 3 states based on inspection + treatment status
sites_data &lt;- sites_data %&gt;%
  mutate(
    final_status = case_when(
      sitecode %in% treated_sites ~ "treated",           # Green - has treatment
      treatment_status == "need_treatment" ~ "need_treatment",  # Red - needs treatment  
      treatment_status == "under_threshold" ~ "under_threshold", # Grey - no treatment needed
      TRUE ~ "under_threshold"
    ),
    state = final_status  # UI compatibility
  )
</code></pre>

<h2>Tab 2: Historical Analysis</h2>

<h3>Purpose</h3>
<p>Analyze multi-year trends in cattail inspections and treatment progress across facilities and zones.</p>

<h3>Key Features</h3>
<ul>
<li><strong>Display Metric selector</strong> - Sites Inspected, Sites Need Treatment, Number of Inspections</li>
<li><strong>Time Period selector</strong> - Monthly or Yearly aggregation</li>
<li><strong>Chart Type selector</strong> - Line Chart or Bar Chart</li>
<li><strong>Date Range controls</strong> - Start and end dates (defaults to 2022-01-01 to current)</li>
<li><strong>Zone/Facility filters</strong> - Same as Progress Overview tab</li>
<li><strong>Group By selector</strong> - Facility, Foreman (FOS), or Zone</li>
</ul>

<h3>Data Flow</h3>
<ol>
<li>Query historical data via <code>get<em>historical</em>cattail_data()</code>:</li>
<ul>
<li>Combine current and archive inspection tables</li>
<li>Filter for cattail inspections (<code>action = '9'</code>)</li>
<li>Join with site and zone information</li>
<li>Filter by selected date range</li>
</ul>
</ul>

<ol>
<li>Process time periods:</li>
<ul>
<li><strong>Monthly</strong>: Use <code>floor_date(inspdate, "month")</code> for monthly grouping</li>
<li><strong>Yearly</strong>: Use <code>floor_date(inspdate, "year")</code> for yearly grouping</li>
<li>Sort by time period for proper chart ordering</li>
</ul>
</ul>

<ol>
<li>Aggregate via chart creation:</li>
<ul>
<li>Group by selected dimension (facility, foreman, zone) and time period</li>
<li>Calculate metrics:</li>
<ul>
<li><strong>Sites Inspected</strong>: <code>n_distinct(sitecode)</code> - Count unique sites inspected</li>
<li><strong>Sites Need Treatment</strong>: Filter <code>numdip &gt; 0</code> then count distinct sites</li>
<li><strong>Number of Inspections</strong>: <code>n()</code> - Count total inspection instances</li>
</ul>
</ul>
</ul>

<h3>Visualization</h3>
<ul>
<li><strong>Line Charts</strong>: Show trends over time with distinct colors per group</li>
<li><strong>Bar Charts</strong>: Show volumes with grouped or stacked bars</li>
<li><strong>Interactive plotly</strong>: Hover tooltips with detailed information</li>
<li><strong>Legend Management</strong>: Proper legend titles based on chart type (color vs fill)</li>
<li><strong>Date Formatting</strong>: Appropriate axis labels based on time period selection</li>
</ul>

<h2>Code Organization</h2>

<h3>File Structure</h3>
<pre><code class="">
cattail_treatments/
├── app.R                     # Main app - UI orchestration and server logic
├── data_functions.R          # All database queries and data processing
├── display_functions.R       # Visualization helpers (placeholder for future)
├── historical_functions.R    # Historical trends data and plotting
└── NOTES.md                  # This file
</code></pre>

<h3>Key Functions by File</h3>

<h4>app.R</h4>
<ul>
<li><code>cattail_values()</code> - Reactive value box calculations with 3-state metrics</li>
<li>Server output renderers:</li>
<ul>
<li><code>output$progress_chart</code> - 3-state progress chart</li>
<li><code>output$historical_chart</code> - Historical trend analysis</li>
<li>Value box outputs for all 3 states plus completion rate</li>
</ul>
</ul>

<h4>data_functions.R</h4>
<ul>
<li><code>load<em>cattail</em>data()</code> - Main data loading with inspection sites and treatments</li>
<li><code>load<em>cattail</em>treatments()</code> - Treatment data loading with seasonal logic</li>
<li><code>aggregate<em>cattail</em>data()</code> - 3-state aggregation with treatment matching</li>
<li><code>filter<em>cattail</em>data()</code> - Apply UI filters (zone, facility, foreman, date range)</li>
</ul>

<h4>historical_functions.R</h4>
<ul>
<li><code>get<em>historical</em>cattail_data()</code> - Queries combined historical inspection data</li>
<li><code>create<em>historical</em>analysis_chart()</code> - Generates historical charts with multiple options</li>
<li>UI helper functions for time period, chart type, and date range selectors</li>
</ul>

<h2>Data Collection and Aggregation Logic</h2>

<h3>Overview of Data Processing Pipeline</h3>
<p>The cattail treatments app processes inspection and treatment data separately, then matches them in R to determine the final 3-state status.</p>

<h3>Core Aggregation Methods</h3>

<h4>3-State Sites Calculation</h4>
<p><strong>All calculations performed in R using dplyr after SQL returns raw records:</strong></p>

<p><strong>Inspection Sites Classification:</strong></p>
<pre><code class="r">
# Classify sites based on cattail dip count (numdip)
cattail_sites &lt;- cattail_sites %&gt;%
  mutate(
    treatment_status = case_when(
      numdip &gt; 0 ~ "need_treatment",    # Red - cattail found
      numdip == 0 ~ "under_threshold", # Grey - no cattail
      TRUE ~ "under_threshold"         # Default to safe state
    )
  )
</code></pre>

<p><strong>Treatment Matching Logic:</strong></p>
<pre><code class="r">
# Match treatments to sites for current inspection year
treated_sites &lt;- treatments %&gt;%
  filter(inspection_year == current_year) %&gt;%  # Match to inspection year
  pull(sitecode) %&gt;%
  unique()

# Update final status based on treatment application
sites_data &lt;- sites_data %&gt;%
  mutate(
    final_status = case_when(
      sitecode %in% treated_sites ~ "treated",              # Green - treated
      treatment_status == "need_treatment" ~ "need_treatment", # Red - still needs treatment
      treatment_status == "under_threshold" ~ "under_threshold", # Grey - no treatment needed
      TRUE ~ "under_threshold"
    ),
    state = final_status  # For UI compatibility
  )
</code></pre>

<p><strong>Progress Metrics:</strong></p>
<pre><code class="r">
# Calculate 3-state summary metrics
total_summary &lt;- data.frame(
  under_threshold_sites = sum(sites_data$final_status == 'under_threshold', na.rm = TRUE),
  need_treatment_sites = sum(sites_data$final_status == 'need_treatment', na.rm = TRUE),
  treated_sites = sum(sites_data$final_status == 'treated', na.rm = TRUE),
  
  # Treatment completion rate
  treatment_completion_rate = ifelse(
    sum(sites_data$final_status %in% c('need_treatment', 'treated'), na.rm = TRUE) &gt; 0,
    round(100 * sum(sites_data$final_status == 'treated', na.rm = TRUE) / 
          sum(sites_data$final_status %in% c('need_treatment', 'treated'), na.rm = TRUE), 1),
    0
  )
)
</code></pre>

<h4>Historical Metrics Aggregation</h4>
<p><strong>All historical aggregations done in R after SQL returns raw inspection records:</strong></p>

<p><strong>Sites Inspected Metric:</strong></p>
<pre><code class="r">
# Count unique sites inspected per group per time period
if (display_metric == "sites") {
  plot_data &lt;- historical_data %&gt;%
    group_by(time_group, group_label) %&gt;%
    summarise(value = n_distinct(sitecode), .groups = "drop")
}
</code></pre>

<p><strong>Sites Need Treatment Metric:</strong></p>
<pre><code class="r">
# Count unique sites needing treatment per group per time period  
if (display_metric == "need_treatment") {
  plot_data &lt;- historical_data %&gt;%
    filter(state == "need_treatment") %&gt;%  # Only sites with numdip &gt; 0
    group_by(time_group, group_label) %&gt;%
    summarise(value = n_distinct(sitecode), .groups = "drop")
}
</code></pre>

<p><strong>Number of Inspections Metric:</strong></p>
<pre><code class="r">
# Count total inspection instances per group per time period
if (display_metric == "inspections") {
  plot_data &lt;- historical_data %&gt;%
    group_by(time_group, group_label) %&gt;%
    summarise(value = n(), .groups = "drop")  # n() counts all inspection records
}
</code></pre>

<h3>Treatment Seasonal Logic (R-based)</h3>
<p><strong>Treatment Season Classification:</strong></p>
<pre><code class="r">
treatments &lt;- treatments %&gt;%
  mutate(
    treatment_season = case_when(
      trt_month %in% c(9, 10, 11, 12) ~ "Fall/Winter",      # Sept-Dec
      trt_month %in% c(5, 6, 7, 8) ~ "Spring/Summer",       # May-Aug  
      TRUE ~ "Other"
    ),
    # Map treatment year to inspection year
    inspection_year = case_when(
      treatment_season == "Fall/Winter" ~ trt_year,          # Same year
      treatment_season == "Spring/Summer" ~ trt_year - 1,    # Previous year
      TRUE ~ trt_year
    )
  )
</code></pre>

<h3>Data Sources vs Aggregation Separation</h3>

<p><strong>SQL Queries</strong>: Return raw, individual records</p>
<ul>
<li><code>load<em>cattail</em>data()</code>: Returns individual inspection site records with most recent inspection per site</li>
<li><code>load<em>cattail</em>treatments()</code>: Returns individual treatment records with seasonal classification</li>
<li><code>get<em>historical</em>cattail_data()</code>: Returns individual historical inspections</li>
</ul>

<p><strong>R Aggregation</strong>: Processes raw records into summaries</p>
<ul>
<li><code>aggregate<em>cattail</em>data()</code>: Matches treatments to sites and calculates 3-state metrics</li>
<li>Historical chart functions: Aggregate by time period and grouping dimension</li>
<li>Value box calculations: Summarize overall 3-state statistics</li>
</ul>

<h2>SQL Queries Reference</h2>

<p>This section documents all SQL queries used in the cattail treatments app for reference and troubleshooting.</p>

<h3>1. Cattail Inspection Sites Query  </h3>
<p><strong>Function</strong>: <code>load<em>cattail</em>data()</code> in <code>data_functions.R</code>  </p>
<p><strong>Purpose</strong>: Load cattail inspection sites with zone and treatment need determination</p>

<pre><code class="sql">
WITH breeding_sites AS (
  SELECT 
    sc.facility, 
    sc.zone, 
    sc.fosarea, 
    LEFT(b.sitecode,7) AS sectcode,
    b.sitecode,
    b.acres,
    b.air_gnd,
    CASE WHEN b.drone IS NOT NULL THEN 'D' ELSE NULL END as drone,
    sc.fosarea as foreman
  FROM public.loc_breeding_sites b
  LEFT JOIN public.gis_sectcode sc ON LEFT(b.sitecode,7) = sc.sectcode
  WHERE (b.enddate IS NULL OR b.enddate &gt; $1)
),
inspection_data AS (
  -- Get the most recent inspection per site (distinct sites only)
  WITH all_inspections AS (
    -- Current year inspections
    SELECT 
      i.sitecode,
      i.inspdate,
      i.action,
      i.numdip,
      i.acres_plan,
      EXTRACT(year FROM i.inspdate) as year
    FROM public.dblarv_insptrt_current i
    WHERE i.inspdate BETWEEN $2 AND $1
      AND i.action = '9'  -- Action 9 = inspected
    
    UNION ALL
    
    -- Archive inspections (if include_archive is true)
    SELECT 
      a.sitecode,
      a.inspdate,
      a.action,
      a.numdip,
      a.acres_plan,
      EXTRACT(year FROM a.inspdate) as year
    FROM public.dblarv_insptrt_archive a
    WHERE $3 = TRUE
      AND a.inspdate BETWEEN $2 AND $1
      AND a.action = '9'  -- Action 9 = inspected
  )
  SELECT DISTINCT ON (sitecode)
    sitecode,
    inspdate,
    action,
    numdip,
    acres_plan,
    year
  FROM all_inspections
  ORDER BY sitecode, inspdate DESC  -- Most recent inspection per site
)
SELECT 
  b.sitecode,
  b.sectcode,
  b.acres,
  b.air_gnd,
  b.drone,
  b.facility,
  b.zone,
  b.fosarea,
  b.foreman,
  -- Add display and calculated fields
  b.facility as facility_display,  -- We'll map this later
  0 as treated_acres,  -- Placeholder for display functions
  -- Determine treatment state - all sites are inspected since we use INNER JOIN
  CASE 
    WHEN i.sitecode IS NOT NULL THEN 'inspected'
    ELSE 'inspected'  -- This shouldn't happen with INNER JOIN
  END as inspection_status,
  CASE 
    WHEN i.numdip &gt; 0 THEN 'need_treatment'
    WHEN i.numdip = 0 THEN 'under_threshold' 
    ELSE 'under_threshold'  -- Default to under_threshold for safety
  END as treatment_status,
  i.inspdate,
  i.numdip,
  i.acres_plan,
  i.year as inspection_year
FROM breeding_sites b
INNER JOIN inspection_data i ON b.sitecode = i.sitecode  -- Only inspected sites
ORDER BY b.sitecode
</code></pre>

<p><strong>Key Points</strong>:</p>
<ul>
<li><strong>CTE Structure</strong>: Uses CTEs for clear separation of site and inspection logic</li>
<li><strong>DISTINCT ON</strong>: Ensures one record per site with most recent inspection</li>
<li><strong>Action Filter</strong>: <code>action = '9'</code> identifies inspection records (vs treatment records)</li>
<li><strong>Treatment Need Logic</strong>: <code>numdip &gt; 0</code> indicates cattail found and treatment needed</li>
<li><strong>Active Sites</strong>: Filters for sites with <code>enddate IS NULL</code> or active during analysis period</li>
<li><strong>Archive Support</strong>: Optionally includes archived inspections based on parameter</li>
</ul>

<h3>2. Cattail Treatments Query</h3>
<p><strong>Function</strong>: <code>load<em>cattail</em>treatments()</code> in <code>data_functions.R</code>  </p>
<p><strong>Purpose</strong>: Load cattail treatments with seasonal timing logic</p>

<pre><code class="sql">
SELECT 
  i.sitecode, 
  i.inspdate AS trtdate, 
  i.action, 
  i.mattype, 
  i.matcode, 
  i.amts, 
  i.acres, 
  sc.facility,
  sc.zone,
  sc.fosarea,
  EXTRACT(year FROM i.inspdate) as trt_year,
  EXTRACT(month FROM i.inspdate) as trt_month
FROM public.dblarv_insptrt_current i
LEFT JOIN public.gis_sectcode sc ON LEFT(i.sitecode,7) = sc.sectcode
WHERE i.action IN ('3', 'A')  -- Action 3 = treatment, Action A = treatment
  AND i.matcode IN (
    SELECT matcode 
    FROM public.mattype_list_targetdose
    WHERE prgassign_default = 'Cat'
  )
  AND (
    -- Fall/winter treatments (same year as inspection)
    (i.inspdate BETWEEN $1 AND $2)
    OR
    -- Spring/summer treatments (year after inspection) 
    (i.inspdate BETWEEN $3 AND $4)
  )

UNION ALL

SELECT 
  a.sitecode, 
  a.inspdate AS trtdate, 
  a.action, 
  a.mattype, 
  a.matcode, 
  a.amts, 
  a.acres, 
  sc.facility,
  sc.zone,
  sc.fosarea,
  EXTRACT(year FROM a.inspdate) as trt_year,
  EXTRACT(month FROM a.inspdate) as trt_month
FROM public.dblarv_insptrt_archive a
LEFT JOIN public.gis_sectcode sc ON LEFT(a.sitecode,7) = sc.sectcode
WHERE a.action IN ('3', 'A')  -- Action 3 = treatment, Action A = treatment
  AND a.matcode IN (
    SELECT matcode 
    FROM public.mattype_list_targetdose
    WHERE prgassign_default = 'Cat'
  )
  AND (
    -- Fall/winter treatments (same year as inspection)
    (a.inspdate BETWEEN $1 AND $2)
    OR
    -- Spring/summer treatments (year after inspection) 
    (a.inspdate BETWEEN $3 AND $4)
  )

ORDER BY trtdate
</code></pre>

<p><strong>Date Parameters</strong>:</p>
<pre><code class="r">
# For current_year = 2024 (inspection year)
fall_start &lt;- as.Date("2024-09-01")    # $1 - Fall treatments start
fall_end &lt;- as.Date("2024-12-31")      # $2 - Fall treatments end
spring_start &lt;- as.Date("2025-05-01")  # $3 - Spring treatments start  
spring_end &lt;- as.Date("2025-07-31")    # $4 - Spring treatments end
</code></pre>

<p><strong>Key Points</strong>:</p>
<ul>
<li><strong>Treatment Actions</strong>: Both <code>action = '3'</code> and <code>action = 'A'</code> represent treatments</li>
<li><strong>Material Validation</strong>: JOIN with <code>mattype<em>list</em>targetdose WHERE prgassign_default = 'Cat'</code></li>
<li><strong>Seasonal Windows</strong>: Covers both fall same year and spring following year</li>
<li><strong>UNION ALL</strong>: Combines current and archive treatment records</li>
<li><strong>Geographic Info</strong>: Joins with <code>gis_sectcode</code> for facility/zone assignment</li>
</ul>

<h3>3. Historical Cattail Inspections Query</h3>
<p><strong>Function</strong>: <code>get<em>historical</em>cattail<em>data()</code> in <code>historical</em>functions.R</code>  </p>
<p><strong>Purpose</strong>: Load historical cattail inspections for trend analysis</p>

<pre><code class="sql">
SELECT 
  i.sitecode,
  i.inspdate,
  i.action,
  i.numdip,
  i.acres_plan,
  EXTRACT(year FROM i.inspdate) as year,
  EXTRACT(month FROM i.inspdate) as month,
  EXTRACT(week FROM i.inspdate) as week,
  sc.facility,
  sc.zone,
  sc.fosarea,
  b.acres
FROM public.dblarv_insptrt_current i
LEFT JOIN public.loc_breeding_sites b ON i.sitecode = b.sitecode
LEFT JOIN public.gis_sectcode sc ON LEFT(i.sitecode,7) = sc.sectcode
WHERE i.inspdate BETWEEN $1 AND $2
  AND i.action = '9'  -- Action 9 = inspected
  AND (b.enddate IS NULL OR b.enddate &gt; $2)

UNION ALL

SELECT 
  a.sitecode,
  a.inspdate,
  a.action,
  a.numdip,
  a.acres_plan,
  EXTRACT(year FROM a.inspdate) as year,
  EXTRACT(month FROM a.inspdate) as month,
  EXTRACT(week FROM a.inspdate) as week,
  sc.facility,
  sc.zone,
  sc.fosarea,
  b.acres
FROM public.dblarv_insptrt_archive a
LEFT JOIN public.loc_breeding_sites b ON a.sitecode = b.sitecode
LEFT JOIN public.gis_sectcode sc ON LEFT(a.sitecode,7) = sc.sectcode
WHERE a.inspdate BETWEEN $1 AND $2
  AND a.action = '9'  -- Action 9 = inspected
  AND (b.enddate IS NULL OR b.enddate &gt; $2)

ORDER BY inspdate
</code></pre>

<p><strong>Key Points</strong>:</p>
<ul>
<li><strong>Historical Range</strong>: Uses start<em>date and end</em>date parameters for flexible date ranges</li>
<li><strong>Time Extractions</strong>: Extracts year, month, week for different aggregation periods</li>
<li><strong>All Inspections</strong>: Does NOT use DISTINCT ON - includes all historical inspections</li>
<li><strong>Active Sites Filter</strong>: Ensures sites were active during the analysis period</li>
<li><strong>Archive Integration</strong>: Combines current and archive tables for complete history</li>
</ul>

<h3>4. Treatment Season Classification (R Logic)</h3>
<p><strong>Function</strong>: R processing in <code>load<em>cattail</em>treatments()</code>  </p>
<p><strong>Purpose</strong>: Classify treatments by season and map to inspection years</p>

<pre><code class="r">
# Add treatment season classification
treatments &lt;- treatments %&gt;%
  mutate(
    trtdate = as.Date(trtdate),
    treatment_season = case_when(
      trt_month %in% c(9, 10, 11, 12) ~ "Fall/Winter",
      trt_month %in% c(5, 6, 7, 8) ~ "Spring/Summer", 
      TRUE ~ "Other"
    ),
    inspection_year = case_when(
      treatment_season == "Fall/Winter" ~ trt_year,     # Same year as inspection
      treatment_season == "Spring/Summer" ~ trt_year - 1, # Previous year inspection
      TRUE ~ trt_year
    ),
    action_desc = case_when(
      action == '3' ~ "Treatment",
      action == 'A' ~ "Treatment", 
      TRUE ~ paste("Action", action)
    )
  )
</code></pre>

<p><strong>Key Points</strong>:</p>
<ul>
<li><strong>Season Windows</strong>: Fall/Winter (Sept-Dec), Spring/Summer (May-Aug)</li>
<li><strong>Year Mapping</strong>: Spring treatments in year N+1 map to year N inspections</li>
<li><strong>Treatment Types</strong>: Both action '3' and 'A' classified as "Treatment"</li>
<li><strong>Inspection Matching</strong>: <code>inspection_year</code> used to match treatments to inspection cycles</li>
</ul>

<h3>5. 3-State Aggregation Logic (R Logic)</h3>
<p><strong>Function</strong>: R processing in <code>aggregate<em>cattail</em>data()</code>  </p>
<p><strong>Purpose</strong>: Calculate final treatment status by matching inspections with treatments</p>

<pre><code class="r">
# Match treatments to sites for current year
if (!is.null(treatments) &amp;&amp; nrow(treatments) &gt; 0) {
  # Get sites that were treated in the current year cycle
  treated_sites &lt;- treatments %&gt;%
    filter(inspection_year == current_year) %&gt;%
    pull(sitecode) %&gt;%
    unique()
  
  # Update treatment status to include 'treated' state
  sites_data &lt;- sites_data %&gt;%
    mutate(
      final_status = case_when(
        sitecode %in% treated_sites ~ "treated",
        treatment_status == "need_treatment" ~ "need_treatment", 
        treatment_status == "under_threshold" ~ "under_threshold",
        TRUE ~ "under_threshold"
      ),
      # Update state field to match final_status for UI compatibility
      state = final_status
    )
} else {
  # No treatments data, use original status
  sites_data$final_status &lt;- sites_data$treatment_status
  sites_data$state &lt;- sites_data$treatment_status
}
</code></pre>

<p><strong>Key Points</strong>:</p>
<ul>
<li><strong>Treatment Matching</strong>: Uses <code>inspection_year</code> to match treatments to inspection cycles</li>
<li><strong>3-State Logic</strong>: under<em>threshold → need</em>treatment → treated progression</li>
<li><strong>Site-Based</strong>: Tracks unique sites, not treatment instances</li>
<li><strong>Fallback Logic</strong>: Handles case when no treatments are available</li>
<li><strong>UI Compatibility</strong>: Maintains <code>state</code> field for existing UI components</li>
</ul>
    </div>
</body>
</html>
