<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trap Surveillance Vector Index - Technical Notes</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 8px;
        }
        h3 {
            color: #7f8c8d;
            margin-top: 20px;
        }
        h4 {
            color: #95a5a6;
            margin-top: 15px;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #e74c3c;
        }
        pre {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            border: 1px solid #34495e;
        }
        pre code {
            background-color: transparent;
            color: #ecf0f1;
            padding: 0;
            border-radius: 0;
            font-size: 0.85em;
        }
        ul, ol {
            margin: 10px 0;
            padding-left: 30px;
        }
        li {
            margin: 5px 0;
        }
        blockquote {
            border-left: 4px solid #3498db;
            background-color: #f8f9fa;
            padding: 10px 20px;
            margin: 20px 0;
            font-style: italic;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f5f5f5;
            font-weight: bold;
        }
        hr {
            border: none;
            height: 2px;
            background-color: #ecf0f1;
            margin: 20px 0;
        }
        p {
            margin: 10px 0;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
<h1>Trap Surveillance Vector Index - Technical Notes</h1>

<h2>Overview</h2>
<p>This app calculates a <strong>Vector Index</strong> for each section using a k-Nearest Neighbors (k-NN) inverse-distance weighted algorithm based on trap surveillance data.</p>

<h2>Data Sources</h2>

<h3>Tables Used</h3>
<ul>
<li><strong><code>dbadult<em>insp</em>current</code></strong> - Current adult mosquito trap inspection records</li>
<ul>
<li>Contains trap locations (x, y coordinates), inspection dates, facility, survey type</li>
<li>Multiple inspections per trap location over time</li>
</ul>
</ul>

<ul>
<li><strong><code>dbadult<em>species</em>current</code></strong> - Species counts for each trap inspection</li>
<ul>
<li>Links to inspections via <code>ainspecnum</code></li>
<li>Contains species code (<code>spp</code>) and count (<code>cnt</code>)</li>
</ul>
</ul>

<ul>
<li><strong><code>lookup_specieslist</code></strong> - Species lookup table</li>
<ul>
<li>Maps species codes to genus/species names</li>
</ul>
</ul>

<ul>
<li><strong><code>gis_sectcode</code></strong> - Section geometry polygons</li>
<ul>
<li>Stored in EPSG:26915 (UTM Zone 15N)</li>
<li>Converted to EPSG:4326 (WGS84 lat/lon) for display</li>
</ul>
</ul>

<h2>Trap Types (Survey Types)</h2>
<p>The app filters for specific trap types using the <code>survtype</code> column:</p>
<ul>
<li><strong>4</strong> - Elevated CO2</li>
<li><strong>5</strong> - Gravid Trap  </li>
<li><strong>6</strong> - CO2 Overnight</li>
</ul>

<p>Note: <code>survtype</code> is stored as <code>character varying</code> in the database, not integer.</p>

<h2>SQL Query Logic</h2>

<h3>Step 1: Rank Trap Inspections</h3>
<pre><code class="sql">
WITH ranked_traps AS (
  SELECT t.ainspecnum, t.facility, t.x, t.y, t.survtype, t.inspdate,
         ROW_NUMBER() OVER (PARTITION BY t.x, t.y, t.facility ORDER BY t.inspdate DESC) as rn
  FROM public.dbadult_insp_current t
  WHERE t.inspdate::date &lt;= [analysis_date]
    AND t.x IS NOT NULL AND t.y IS NOT NULL
    AND t.survtype IN ('4','5','6')
    [AND t.facility IN (...)]  -- optional facility filter
)
</code></pre>
<p><strong>Purpose</strong>: Since traps are inspected multiple times per year, we use <code>ROW_NUMBER()</code> partitioned by location (<code>x, y, facility</code>) and ordered by <code>inspdate DESC</code> to identify the most recent inspection at each unique trap location.</p>

<h3>Step 2: Get Latest Traps Only</h3>
<pre><code class="sql">
latest_traps AS (
  SELECT ainspecnum, facility, x, y, survtype, inspdate
  FROM ranked_traps
  WHERE rn = 1
)
</code></pre>
<p><strong>Purpose</strong>: Filter to only the most recent inspection per location (<code>rn = 1</code>).</p>

<h3>Step 3: Join Species Counts</h3>
<pre><code class="sql">
SELECT lt.ainspecnum, lt.facility, lt.x as lon, lt.y as lat, lt.survtype, lt.inspdate::date as inspdate,
       COALESCE(SUM(s.cnt), 0) as species_count
FROM latest_traps lt
LEFT JOIN public.dbadult_species_current s ON lt.ainspecnum = s.ainspecnum
  [AND s.spp IN (...)]  -- optional species filter
GROUP BY lt.ainspecnum, lt.facility, lt.x, lt.y, lt.survtype, lt.inspdate
</code></pre>
<p><strong>Purpose</strong>: </p>
<ul>
<li>Join species counts to each trap</li>
<li>If species filter is active, only count selected species</li>
<li><code>COALESCE(SUM(s.cnt), 0)</code> ensures traps with no species get count = 0</li>
<li>GROUP BY required because LEFT JOIN can return multiple rows per trap (one per species)</li>
</ul>

<p><strong>Result</strong>: One row per unique trap location with:</p>
<ul>
<li>Most recent inspection date</li>
<li>Species count (filtered by selected species if applicable)</li>
<li>No duplicate locations</li>
</ul>

<h2>Vector Index Calculation</h2>

<h3>Algorithm: k-Nearest Neighbors with Inverse Distance Weighting</h3>

<p>For each section, we:</p>

<ol>
<li><strong>Find k nearest traps</strong> - Default k=4 (user adjustable 1-10)</li>
<ul>
<li>Calculate distance from section centroid to all trap locations</li>
<li>Sort by distance and take top k traps</li>
</ul>
</ul>

<ol>
<li><strong>Calculate inverse distance weights</strong></li>
</ul>
<p>   ```r</p>
<p>   weights = 1 / distance</p>
<p>   ```</p>
<ul>
<li>Closer traps have higher weights</li>
<li>If distance = 0 (trap exactly on section centroid), set to 1e-6 to avoid division by zero</li>
</ul>
</ul>

<ol>
<li><strong>Compute weighted average</strong></li>
</ul>
<p>   ```r</p>
<p>   vector<em>index = sum(weights * species</em>counts) / sum(weights)</p>
<p>   ```</p>
<ul>
<li>Multiply each trap's species count by its weight</li>
<li>Divide by sum of weights to normalize</li>
</ul>
</ul>

<h3>Example Calculation</h3>
<p>Section with k=4 nearest traps:</p>
<ul>
<li>Trap 1: 24km away, 106 mosquitoes → weight = 1/24057 = 0.000042</li>
<li>Trap 2: 24km away, 76 mosquitoes → weight = 0.000042</li>
<li>Trap 3: 24km away, 1 mosquito → weight = 0.000042</li>
<li>Trap 4: 24km away, 90 mosquitoes → weight = 0.000042</li>
</ul>

<pre><code class="">
vector_index = (0.000042 * 106 + 0.000042 * 76 + 0.000042 * 1 + 0.000042 * 90) / (0.000042 * 4)
             = 0.011466 / 0.000168
             = 68.25
</code></pre>

<h2>Metrics Explained</h2>

<h3>Vector Index</h3>
<p><strong>Definition</strong>: A distance-weighted estimate of mosquito abundance for each section based on nearby trap counts.</p>

<p><strong>Interpretation</strong>:</p>
<ul>
<li>Higher values = More mosquitoes in nearby traps (weighted by proximity)</li>
<li>Lower values = Fewer mosquitoes or far from active traps</li>
<li>Value of 0 = No mosquitoes in k nearest traps</li>
</ul>

<p><strong>Use Case</strong>: Provides a spatial interpolation of mosquito activity across sections, even those without traps, based on nearby trap surveillance data.</p>

<h3>Nearest Trap Total</h3>
<p><strong>Definition</strong>: Simple sum of species counts from the k nearest traps (unweighted).</p>

<pre><code class="r">
nearest_trap_count = sum(species_counts from k nearest traps)
</code></pre>

<p><strong>Purpose</strong>: </p>
<ul>
<li>Provides context for the vector index</li>
<li>Shows the raw total count contributing to the calculation</li>
<li>Helps identify if high vector index is due to a few high-count traps or many moderate-count traps</li>
</ul>

<p><strong>Example</strong>: If k=4 and nearest trap counts are [106, 76, 1, 90], then <code>nearest<em>trap</em>total = 273</code></p>

<h2>Spatial Operations &amp; sf Package Implementation</h2>

<h3>SF (Simple Features) Package Overview</h3>
<p>The app extensively uses the <code>sf</code> package for spatial operations, which provides standardized access to simple features. This includes reading shapefiles, coordinate transformations, spatial queries, and geometric operations.</p>

<h3>Shapefile Loading &amp; Layer Management</h3>

<h4>Primary Spatial Data Sources</h4>
<ol>
<li><strong>Section Boundaries</strong> - The core spatial layer containing section polygons</li>
<li><strong>Background Layers</strong> - Supporting geographic context (facilities, counties, zones)</li>
<li><strong>Point Data</strong> - Trap locations converted from coordinates to spatial features</li>
</ul>

<h4>Load Section Geometries Function (<code>load<em>section</em>geometries()</code>)</h4>
<pre><code class="r">
# Hierarchical loading strategy for section boundaries
1. Try GeoPackage (.gpkg) format first: "shared/Q_to_R/data/sections_boundaries.gpkg"
2. Fallback to Shapefile (.shp): "shared/Q_to_R/data/sections_boundaries.shp"  
3. Final fallback to database query with PostGIS geometry extraction
</code></pre>

<p><strong>sf Operations Applied:</strong></p>
<ul>
<li><code>st_read()</code> - Read spatial data from files or database</li>
<li><code>st<em>is</em>longlat()</code> - Check if CRS is geographic (lat/lon)</li>
<li><code>st_transform(4326)</code> - Ensure consistent WGS84 coordinate system</li>
<li><code>st<em>make</em>valid()</code> - Clean up any invalid polygon geometries</li>
</ul>

<h4>Background Layer Loading (<code>load<em>background</em>layers()</code>)</h4>
<p>The app dynamically loads multiple background layers from shared directories:</p>

<p><strong>Layer Hierarchy:</strong></p>
<ol>
<li><strong>Facilities</strong> - Administrative boundaries for mosquito control districts</li>
<ul>
<li>Primary: <code>shared/Q<em>to</em>R/data/facility_boundaries.shp</code></li>
<li>Fallback: <code>mosquito<em>surveillance</em>map/shp/FacilityArea_4326.shp</code></li>
</ul>
</ul>

<ol>
<li><strong>Zones</strong> - P1/P2 zone boundaries  </li>
<ul>
<li>Primary: <code>shared/Q<em>to</em>R/data/zone_boundaries.shp</code></li>
<li>Fallback: <code>mosquito<em>surveillance</em>map/shp/P1zonebdry_4326.shp</code></li>
</ul>
</ul>

<ol>
<li><strong>Counties</strong> - Administrative context</li>
<ul>
<li>Source: <code>mosquito<em>surveillance</em>map/shp/Counties_4326.shp</code></li>
</ul>
</ul>

<p><strong>Purpose</strong>: Provides geographic context and reference layers without querying the database repeatedly.</p>

<h3>Coordinate Systems &amp; Transformations</h3>
<ol>
<li><strong>Database Storage</strong>: </li>
<ul>
<li>Traps: EPSG:4326 (WGS84 lat/lon) stored as x, y</li>
<li>Sections: EPSG:26915 (UTM Zone 15N) in PostGIS <code>the_geom</code> column</li>
</ul>
</ul>

<ol>
<li><strong>sf Transformation Pipeline</strong>: </li>
</ul>
<p>   ```r</p>
<p>   # Step 1: Convert coordinates to sf objects</p>
<p>   traps<em>sf &lt;- st</em>as_sf(traps, coords = c("lon", "lat"), crs = 4326)</p>
<p>   sects<em>sf &lt;- st</em>as_sf(sects, coords = c("lon", "lat"), crs = 4326)</p>

<p>   # Step 2: Transform to projected CRS for accurate distance calculation</p>
<p>   traps<em>m &lt;- st</em>transform(traps_sf, 3857)  # Web Mercator meters</p>
<p>   sects<em>m &lt;- st</em>transform(sects_sf, 3857)  # Web Mercator meters</p>

<p>   # Step 3: Use st_distance() for precise meter-based calculations</p>
<p>   dists &lt;- as.numeric(st<em>distance(sect</em>row, traps_m))</p>
<p>   ```</p>

<ol>
<li><strong>Display Preparation</strong>: </li>
<ul>
<li>All layers transformed back to EPSG:4326 for map rendering</li>
<li>Consistent CRS ensures proper overlay of all spatial elements</li>
</ul>
</ul>

<h3>SF-Based Map Rendering</h3>

<h4>Static Map with ggplot2 + ggspatial (<code>render<em>vector</em>map_sf()</code>)</h4>
<p>The app creates publication-quality static maps using <code>ggplot2</code> with <code>ggspatial</code> for basemap tiles:</p>

<p><strong>Layer Rendering Order (back to front):</strong></p>
<pre><code class="r">
1. Basemap Tiles (ggspatial)
   annotation_map_tile(type = "cartolight", zoomin = 2, alpha = 1.0)

2. County Boundaries (context)
   geom_sf(data = bg_layers$counties, color = "gray80", alpha = 0.3)

3. Facility Boundaries (reference)  
   geom_sf(data = bg_layers$facilities, color = "gray40", linetype = "dashed")

4. Section Polygons (main data)
   geom_sf(data = sections_sf, aes(fill = vector_index), alpha = 0.8)

5. Trap Points (overlay data)
   geom_sf(data = traps_sf, aes(color = trap_label, size = species_count))
</code></pre>

<p><strong>sf-Specific Features:</strong></p>
<ul>
<li><code>geom_sf()</code> automatically handles spatial geometries (polygons, points, lines)</li>
<li><code>coord_sf()</code> sets map projection and extent based on bounding box</li>
<li><code>st_bbox()</code> calculates extent from actual geometry bounds</li>
<li><code>inherit.aes = FALSE</code> prevents coordinate conflicts between layers</li>
</ul>

<h4>Dynamic Basemap Integration</h4>
<pre><code class="r">
# ggspatial provides seamless OSM tile integration
annotation_map_tile(type = "cartolight", zoomin = 2, alpha = 1.0, progress = "none", quiet = TRUE)
</code></pre>
<ul>
<li>Downloads tiles automatically based on plot extent</li>
<li><code>zoomin = 2</code> requests higher resolution tiles for detail</li>
<li><code>type = "cartolight"</code> provides clean, minimal basemap styling</li>
</ul>

<h4>Interactive Map with Leaflet (<code>render<em>vector</em>map()</code>)</h4>
<p>Traditional Leaflet implementation for comparison:</p>
<ul>
<li>Point-based representation using <code>addCircleMarkers()</code></li>
<li>Manual popup construction with HTML formatting</li>
<li>Layer control for toggling sections vs traps</li>
<li>Less detailed than sf-based approach but more interactive</li>
</ul>

<h3>Spatial Data Processing Pipeline</h3>

<h4>Point-to-SF Conversion</h4>
<pre><code class="r">
# Convert tabular coordinates to spatial features
traps_sf &lt;- st_as_sf(trap_df, coords = c("lon", "lat"), crs = 4326, remove = FALSE)

# remove = FALSE preserves original lon/lat columns alongside geometry
# Essential for maintaining data table compatibility
</code></pre>

<h4>Geometry Operations</h4>
<pre><code class="r">
# Centroid calculation for KNN
sections_centroids &lt;- suppressWarnings(st_centroid(sections_sf))

# Extract coordinates for tabular operations
coords &lt;- st_coordinates(sections_centroids)
lon &lt;- coords[,1]
lat &lt;- coords[,2]

# Drop geometry when converting back to data.frame
st_drop_geometry(sections_centroids)
</code></pre>

<h4>Distance-Based Spatial Analysis</h4>
<pre><code class="r">
# Vectorized distance calculation between all sections and traps
dists &lt;- as.numeric(st_distance(sect_row, traps_m))

# Find k-nearest neighbors using R sorting (faster than spatial index)
k_idx &lt;- order(dists)[1:k_actual]
</code></pre>

<h3>Why Transform for Distance?</h3>
<p>Lat/lon coordinates are angular (degrees), not linear. Direct Euclidean distance in lat/lon is inaccurate. The sf package handles this by:</p>
<ol>
<li><strong>EPSG:4326</strong> - Geographic coordinates for storage/display</li>
<li><strong>EPSG:3857</strong> - Projected coordinates for accurate meter-based calculations  </li>
<li><strong>st_distance()</strong> - Proper geodesic calculations accounting for Earth's curvature</li>
</ul>

<h3>Performance Optimizations with sf</h3>

<h4>File Format Preference</h4>
<ol>
<li><strong>GeoPackage (.gpkg)</strong> - Faster loading, better compression, single-file format</li>
<li><strong>Shapefile (.shp)</strong> - Traditional format, multiple files (.shp, .shx, .dbf, .prj)</li>
<li><strong>PostGIS query</strong> - Database fallback when files unavailable</li>
</ul>

<h4>Memory Management</h4>
<ul>
<li><code>quiet = TRUE</code> suppresses verbose sf output</li>
<li><code>st<em>make</em>valid()</code> cleans geometries once during loading</li>
<li>Background layers loaded once and cached in function scope</li>
<li>Geometry operations vectorized using sf's compiled C++ backends</li>
</ul>

<h4>Spatial Indexing</h4>
<ul>
<li>sf automatically builds spatial indexes for large datasets</li>
<li><code>st_distance()</code> leverages GEOS library for optimized calculations</li>
<li>R-side processing faster than multiple database calls for this use case</li>
</ul>

<h2>Data Type Issues &amp; Solutions</h2>

<h3>Integer64 Problem</h3>
<p>PostgreSQL's <code>SUM()</code> on integer columns returns <code>integer64</code> type in R. When multiplying very small decimals (weights like 0.000042) by integer64 values, precision loss can occur.</p>

<p><strong>Solution</strong>: Convert to numeric before calculation</p>
<pre><code class="r">
counts &lt;- as.numeric(traps_m$species_count[k_idx])
</code></pre>

<h3>Species Code Handling</h3>
<p>Species codes (<code>sppcode</code>) are numeric but stored as integers in the database. When building SQL IN clauses, they must NOT be quoted:</p>
<pre><code class="sql">
-- Correct
WHERE s.spp IN (1, 2, 3)

-- Incorrect (causes type mismatch)
WHERE s.spp IN ('1', '2', '3')
</code></pre>

<h2>Performance Optimizations</h2>

<ol>
<li><strong>Single Query Strategy</strong>: Fetch all traps with species counts in one query rather than:</li>
<ul>
<li>Query 1: Get traps</li>
<li>Query 2: Get species counts</li>
<li>R join operation</li>
</ul>
</ul>

<ol>
<li><strong>Filter Early</strong>: Apply facility and species filters in SQL before returning data to R</li>
</ul>

<ol>
<li><strong>R-side Spatial Operations</strong>: </li>
<ul>
<li>After fetching data, all distance calculations happen in R using vectorized sf operations</li>
<li>Much faster than making 3000+ distance queries to PostgreSQL</li>
</ul>
</ul>

<ol>
<li><strong>Efficient Ranking</strong>: <code>ROW_NUMBER()</code> window function is more efficient than <code>DISTINCT ON</code> for getting latest records</li>
</ul>

<h2>User Controls</h2>

<ul>
<li><strong>Analysis Date</strong>: Only include traps inspected on or before this date</li>
<li><strong>Species Filter</strong>: Select specific species or "All Species" to include all</li>
<li><strong>Trap Types</strong>: Multi-select checkbox for survtypes 4, 5, 6</li>
<li><strong>k (Neighbors)</strong>: Number of nearest traps to consider (1-10, default 4)</li>
<li><strong>Facility Filter</strong>: Filter traps by facility (E, N, Sj, Sr, Wm, Wp, or All)</li>
<li><strong>Refresh Data Button</strong>: Data loads only when clicked (prevents accidental heavy queries)</li>
</ul>

<h2>Map Layers</h2>

<h3>Sections Layer (Yellow-Orange-Red)</h3>
<ul>
<li>Circle size based on <code>log1p(vector_index) * 4</code> - larger for higher indices</li>
<li>Color intensity from yellow (low) to red (high) based on vector index value</li>
<li>Popup shows: Section code, Vector Index, Nearest Trap Total</li>
</ul>

<h3>Traps Layer (Blue)</h3>
<ul>
<li>Small blue circles (radius = 3)</li>
<li>Popup shows: Trap ID, Facility, Trap Type, Inspection Date, Species Count</li>
<li>Species count reflects current filter (e.g., if filtering for Culex pipiens, only shows that species count)</li>
</ul>

<h3>Layer Control</h3>
<p>Toggle sections and traps on/off independently</p>

<h2>Testing</h2>

<p>Run <code>test-sql.R</code> to validate:</p>
<ul>
<li>SQL query returns expected number of rows</li>
<li>Check for duplicate locations</li>
<li>Verify distance calculations work correctly</li>
<li>Review species count distribution</li>
</ul>

<h2>Future Enhancements</h2>

<p>Potential improvements:</p>
<ul>
<li>Add date range filter (instead of single date)</li>
<li>Export results to CSV</li>
<li>Cache species counts for faster reload</li>
<li>Display section polygons instead of centroids</li>
<li>Add time-series animation showing vector index over time</li>
<li>Include trap density as additional metric</li>
</ul>
    </div>
</body>
</html>
